// ColorMatrix Class v1.3//// Author: Mario Klingemann// http://www.quasimondo.com// Changes in v1.1:// Changed the RGB to luminance constants// Added colorize() method// Changes in v1.2:// Added clone() // Added randomize() // Added blend() // Added "filter" property// Changes in v1.3:// Added invertAlpha()// Added thresholdAlpha()package com.quasimondo.geom{	import flash.filters.ColorMatrixFilter;	public class ColorMatrix	{				// RGB to Luminance conversion constants as found on		// Charles A. Poynton's colorspace-faq:		// http://www.faqs.org/faqs/graphics/colorspace-faq/				private static var r_lum:Number = 0.212671;		private static var g_lum:Number = 0.715160;		private static var b_lum:Number = 0.072169;				/*				// There seem  different standards for converting RGB		// values to Luminance. This is the one by Paul Haeberli:				private static var r_lum:Number = 0.3086;		private static var g_lum:Number = 0.6094;		private static var b_lum:Number = 0.0820;				*/				private static var IDENTITY:Array = new Array(1,0,0,0,0,												  0,1,0,0,0,												  0,0,1,0,0,												  0,0,0,1,0);				public var matrix:Array;						/*	   Function: ColorMatrix	   		  Constructor		   Parameters:			  mat - if omitted matrix gets initialized with an				identity matrix. Alternatively it can be 				initialized with another ColorMatrix or 				an array (there is currently no check 				if the array is valid. A correct array 				contains 20 elements.)										*/					public function ColorMatrix ( mat:Object = null)		{			if (mat is ColorMatrix )			{				matrix = mat.matrix.concat();			} else if (mat is Array )			{				matrix = mat.concat();			} else 			{				reset();			}					}				/*	   Function: reset			  resets the matrix to the neutral identity matrix. Applying this		  matrix to an image will not make any changes to it.		   Parameters:			  none		  		Returns:					nothing										*/				public function reset():void		{			matrix = IDENTITY.concat();		}						public function clone():ColorMatrix		{			return new ColorMatrix( matrix );		}						/*	   Function: adjustSaturation			  changes the saturation		   Parameters:			  s - typical values come in the range 0.0 ... 2.0 where					 0.0 means 0% Saturation					 0.5 means 50% Saturation					 1.0 is 100% Saturation (aka no change)					 2.0 is 200% Saturation					 					 Other values outside of this range are possible					 -1.0 will invert the hue but keep the luminance									  		Returns:					nothing										*/				public function adjustSaturation ( s:Number ):void		{			var sat:Number=1-s;						var irlum:Number = sat * r_lum;			var iglum:Number = sat * g_lum;			var iblum:Number = sat * b_lum;						var mat:Array = new Array (irlum + s, iglum    , iblum    , 0, 0,									irlum    , iglum + s, iblum    , 0, 0,									irlum    , iglum    , iblum + s, 0, 0,									0        , 0        , 0        , 1, 0 );								concat(mat);		}						/*	   Function: adjustContrast			  changes the contrast		   Parameters:			  s - typical values come in the range -1.0 ... 1.0 where					 -1.0 means no vontrast (grey)					 0 means no vhange					 1.0 is high contrast														  		Returns:					nothing										*/						public function adjustContrast ( r:Number, g:Number, b:Number ):void		{			g = g || r;			b = b || r;						r+=1;			g+=1;			b+=1;						var mat:Array = new Array(r,0,0,0,128*(1-r),								   0,g,0,0,128*(1-g),								   0,0,b,0,128*(1-b),								   0,0,0,1,0);								concat(mat);		}				public function adjustAlphaContrast ( a:Number ):void		{						a+=1;						var mat:Array = new Array(1,0,0,0,0,								   0,1,0,0,0,								   0,0,1,0,0,								   0,0,0,a,128*(1-a));								concat(mat);		}				public function adjustBrightness (r:Number, g:Number, b:Number):void		{			g = g || r;			b = b || r;						var mat:Array = new Array(1,0,0,0,r,								   0,1,0,0,g ,								   0,0,1,0,b ,								   0,0,0,1,0 );								concat(mat);					}				public function adjustHue( angle:Number ):void		{				angle *= Math.PI/180;								var c:Number = Math.cos( angle );				var s:Number = Math.sin( angle );								var f1:Number = 0.213;				var f2:Number = 0.715;				var f3:Number = 0.072;								var mat:Array = new Array((f1 + (c * (1 - f1))) + (s * (-f1)), (f2 + (c * (-f2))) + (s * (-f2)), (f3 + (c * (-f3))) + (s * (1 - f3)), 0, 0, (f1 + (c * (-f1))) + (s * 0.143), (f2 + (c * (1 - f2))) + (s * 0.14), (f3 + (c * (-f3))) + (s * -0.283), 0, 0, (f1 + (c * (-f1))) + (s * (-(1 - f1))), (f2 + (c * (-f2))) + (s * f2), (f3 + (c * (1 - f3))) + (s * f3), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);								concat(mat);		}				public function colorize ( rgb:Number, amount:Number = 1):void		{						var r:Number = ( ( rgb >> 16 ) & 0xff ) / 255;			var g:Number = ( ( rgb >> 8  ) & 0xff ) / 255;			var b:Number = (   rgb         & 0xff ) / 255;						var inv_amount:Number = 1 - amount;									var mat:Array = new Array ( inv_amount + amount*r*r_lum, amount*r*g_lum, amount*r*b_lum, 0, 0,									 amount*g*r_lum, inv_amount + amount*g*g_lum, amount*g*b_lum, 0, 0,									 amount*b*r_lum,amount*b*g_lum, inv_amount + amount*b*b_lum, 0, 0,									 0 , 0 , 0 , 1, 0 );									concat(mat);		}												public function setAlpha( alpha:Number ):void		{			var mat:Array = new Array ( 1, 0, 0, 0, 0,									 0, 1, 0, 0, 0,									 0, 0, 1, 0, 0,									 0, 0, 0, alpha, 0 );						concat(mat);		}				public function desaturate():void		{			var mat:Array = new Array ( r_lum, g_lum, b_lum, 0, 0,									 r_lum, g_lum, b_lum, 0, 0,									 r_lum, g_lum, b_lum, 0, 0,									 0    , 0    , 0    , 1, 0 );						concat(mat);		}				public function average( r:Number = 1/3, g:Number = 1/3, b:Number  = 1/3):void		{						var mat:Array = new Array ( r, g, b, 0, 0,									 r, g, b, 0, 0,									 r, g, b, 0, 0,									 0, 0, 0, 1, 0 );						concat(mat);		}				public function averageRGB2Alpha():void		{			var third:Number = 1/3;			var mat:Array = new Array ( 0, 0, 0, 0, 255,									 0, 0, 0, 0, 255,									 0, 0, 0, 0, 255,									 third, third , third, 0, 0 );						concat(mat);		}				public function rgb2Alpha( r:Number, g:Number, b:Number ):void		{			var mat:Array = new Array ( 0, 0, 0, 0, 255,									 0, 0, 0, 0, 255,									 0, 0, 0, 0, 255,									 r, g, b, 0, 0 );						concat(mat);		}				public function invert():void		{			var mat:Array = new Array ( -1 ,  0,  0, 0, 255,									  0 , -1,  0, 0, 255,									  0 ,  0, -1, 0, 255,									  0,   0,  0, 1,   0);						concat(mat);		}				public function invertAlpha():void		{			var mat:Array = new Array (  1 ,  0,  0, 0, 0,									  0 ,  1,  0, 0, 0,									  0 ,  0,  1, 0, 0,									  0,   0,  0, -1,  255);						concat(mat);		}						public function threshold( t:Number, f:Number=256 ):void		{						var mat:Array = new Array  (	r_lum*f, g_lum*f, b_lum*f, 0,  -f*t, 										r_lum*f ,g_lum*f, b_lum*f, 0,  -f*t, 										r_lum*f, g_lum*f, b_lum*f, 0,  -f*t, 										0, 0, 0, 1, 0); 			concat(mat);		}				public function thresholdAlpha( t:Number, f:Number =256):void		{						var mat:Array = new Array  (	1, 0, 0, 0,  0, 										0, 1, 0, 0,  0, 										0, 0, 1, 0,  0, 										0, 0, 0, f, -f*t); 			concat(mat);		}				public function randomize( amount:Number = 1):void		{						var inv_amount:Number = 1 - amount;						var r1:Number = inv_amount +  amount * ( Math.random() - Math.random() );			var g1:Number = amount     * ( Math.random() - Math.random() );			var b1:Number = amount     * ( Math.random() - Math.random() );						var o1:Number = amount * 255 * (Math.random() - Math.random());						var r2:Number = amount     * ( Math.random() - Math.random() );			var g2:Number = inv_amount +  amount * ( Math.random() - Math.random() );			var b2:Number = amount     * ( Math.random() - Math.random() );						var o2:Number = amount * 255 * (Math.random() - Math.random());									var r3:Number = amount     * ( Math.random() - Math.random() );			var g3:Number = amount     * ( Math.random() - Math.random() );			var b3:Number = inv_amount +  amount * ( Math.random() - Math.random() );						var o3:Number = amount * 255 * (Math.random() - Math.random());						var mat:Array = new Array  (	r1, g1, b1, 0, o1, 										r2 ,g2, b2, 0, o2, 										r3, g3, b3, 0, o3, 										0 ,  0,  0, 1, 0 ); 						concat(mat);		}						public function setChannels (r:Number, g:Number, b:Number, a:Number ):void		{			var rf:Number =((r & 1) == 1 ? 1:0) + ((r & 2) == 2 ? 1:0) + ((r & 4) == 4 ? 1:0) + ((r & 8) == 8 ? 1:0); 			if (rf>0) rf=1/rf;			var gf:Number =((g & 1) == 1 ? 1:0) + ((g & 2) == 2 ? 1:0) + ((g & 4) == 4 ? 1:0) + ((g & 8) == 8 ? 1:0); 			if (gf>0) gf=1/gf;			var bf:Number =((b & 1) == 1 ? 1:0) + ((b & 2) == 2 ? 1:0) + ((b & 4) == 4 ? 1:0) + ((b & 8) == 8 ? 1:0); 			if (bf>0) bf=1/bf;			var af:Number =((a & 1) == 1 ? 1:0) + ((a & 2) == 2 ? 1:0) + ((a & 4) == 4 ? 1:0) + ((a & 8) == 8 ? 1:0); 			if (af>0) af=1/af;						var mat:Array = new Array((r & 1) == 1 ? rf:0,(r & 2) == 2 ? rf:0,(r & 4) == 4 ? rf:0,(r & 8) == 8 ? rf:0,0,								   (g & 1) == 1 ? gf:0,(g & 2) == 2 ? gf:0,(g & 4) == 4 ? gf:0,(g & 8) == 8 ? gf:0,0,								   (b & 1) == 1 ? bf:0,(b & 2) == 2 ? bf:0,(b & 4) == 4 ? bf:0,(b & 8) == 8 ? bf:0,0,								   (a & 1) == 1 ? af:0,(a & 2) == 2 ? af:0,(a & 4) == 4 ? af:0,(a & 8) == 8 ? af:0,0);						concat(mat);					}				public function blend( m:ColorMatrix, amount:Number ):void		{			var inv_amount:Number = 1 - amount;						for (var i:Number = 0; i < 20; i++ )			{				matrix[i] = inv_amount * matrix[i] + amount * m.matrix[i];			}		}				public function concat(mat:Array):void		{						var temp:Array = new Array ();			var i:Number = 0;						for (var y:Number = 0; y < 4; y++ )			{								for (var x:Number = 0; x < 5; x++ )				{					temp[i + x] = mat[i    ] * matrix[x     ] + 								   mat[i+1] * matrix[x +  5] + 								   mat[i+2] * matrix[x + 10] + 								   mat[i+3] * matrix[x + 15] +								   (x == 4 ? mat[i+4] : 0);				}				i+=5;			}						matrix = temp;					}				public function get filter():ColorMatrixFilter		{			return new ColorMatrixFilter( matrix );		}				}}